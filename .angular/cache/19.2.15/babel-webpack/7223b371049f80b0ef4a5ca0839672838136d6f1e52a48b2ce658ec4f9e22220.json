{"ast":null,"code":"import { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"./employee.service\";\nexport class MatchingService {\n  constructor(http, employeeService) {\n    this.http = http;\n    this.employeeService = employeeService;\n    this.apiUrl = `${environment.backendUrl}/jobemployeeskillmatch`;\n  }\n  // Utilise le nouveau controller jobemployeeskillmatch\n  getJobEmployeeSkillMatch(jobId) {\n    return this.http.get(`${this.apiUrl}/${jobId}`);\n  }\n  // Méthode legacy pour compatibilité\n  getMatchingResults(jobId) {\n    return this.getJobEmployeeSkillMatch(jobId);\n  }\n  // Affectation automatique basée sur le score\n  autoAssignEmployeesToJob(jobId, minScore = 70, maxAssignments = 5) {\n    return this.getJobEmployeeSkillMatch(jobId).pipe(map(results => {\n      // Filtrer par score minimum et trier par score décroissant\n      const eligibleEmployees = results.filter(result => result.score >= minScore).sort((a, b) => b.score - a.score).slice(0, maxAssignments); // Limiter le nombre d'affectations\n      return eligibleEmployees;\n    }),\n    // Effectuer les affectations\n    map(eligibleEmployees => {\n      const assignmentPromises = eligibleEmployees.map(result => this.employeeService.assignEmployeeToJobDescription(result.employee_id, jobId).toPromise());\n      return {\n        eligibleEmployees,\n        assignmentPromises: Promise.all(assignmentPromises)\n      };\n    }));\n  }\n  getMatchingAnalytics(jobId) {\n    return this.http.get(`${this.apiUrl}/${jobId}/analytics`);\n  }\n  exportMatchingResults(jobId, format = 'pdf') {\n    return this.http.get(`${this.apiUrl}/${jobId}/export?format=${format}`, {\n      responseType: 'blob'\n    });\n  }\n  // Nouvelle méthode pour trouver le meilleur poste pour un employé\n  findBestJobForEmployee(employeeId) {\n    // On va tester l'employé contre tous les postes disponibles\n    return this.http.get(`${this.apiUrl}/employee/${employeeId}/best-matches`);\n  }\n  // Méthode alternative si le backend n'a pas l'endpoint spécifique\n  findBestJobForEmployeeAlternative(employeeId, jobDescriptions) {\n    // On teste l'employé contre chaque poste et on retourne les résultats triés\n    const matchingPromises = jobDescriptions.map(job => this.getJobEmployeeSkillMatch(job.id).toPromise().then(results => (results ?? []).filter(result => result.employee_id === employeeId)).catch(() => []));\n    return new Observable(observer => {\n      Promise.all(matchingPromises).then(allResults => {\n        const flatResults = allResults.flat().sort((a, b) => b.score - a.score);\n        observer.next(flatResults);\n        observer.complete();\n      }).catch(error => {\n        observer.error(error);\n      });\n    });\n  }\n  static {\n    this.ɵfac = function MatchingService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatchingService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.EmployeeService));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: MatchingService,\n      factory: MatchingService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"names":["Observable","map","environment","MatchingService","constructor","http","employeeService","apiUrl","backendUrl","getJobEmployeeSkillMatch","jobId","get","getMatchingResults","autoAssignEmployeesToJob","minScore","maxAssignments","pipe","results","eligibleEmployees","filter","result","score","sort","a","b","slice","assignmentPromises","assignEmployeeToJobDescription","employee_id","toPromise","Promise","all","getMatchingAnalytics","exportMatchingResults","format","responseType","findBestJobForEmployee","employeeId","findBestJobForEmployeeAlternative","jobDescriptions","matchingPromises","job","id","then","catch","observer","allResults","flatResults","flat","next","complete","error","i0","ɵɵinject","i1","HttpClient","i2","EmployeeService","factory","ɵfac","providedIn"],"sources":["C:\\Users\\h_ref\\Desktop\\frontend\\matchnhire\\src\\app\\services\\matching.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable, forkJoin } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { MatchingResult, MatchingAnalytics } from '../models/matching.model';\nimport { environment } from '../../environments/environment';\nimport { EmployeeService } from './employee.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class MatchingService {\n  private apiUrl = `${environment.backendUrl}/jobemployeeskillmatch`;\n\n  constructor(\n    private http: HttpClient,\n    private employeeService: EmployeeService\n  ) { }\n\n  // Utilise le nouveau controller jobemployeeskillmatch\n  getJobEmployeeSkillMatch(jobId: number): Observable<MatchingResult[]> {\n    return this.http.get<MatchingResult[]>(`${this.apiUrl}/${jobId}`);\n  }\n\n  // Méthode legacy pour compatibilité\n  getMatchingResults(jobId: number): Observable<MatchingResult[]> {\n    return this.getJobEmployeeSkillMatch(jobId);\n  }\n\n  // Affectation automatique basée sur le score\n  autoAssignEmployeesToJob(jobId: number, minScore: number = 70, maxAssignments: number = 5): Observable<any> {\n    return this.getJobEmployeeSkillMatch(jobId).pipe(\n      map(results => {\n        // Filtrer par score minimum et trier par score décroissant\n        const eligibleEmployees = results\n          .filter(result => result.score >= minScore)\n          .sort((a, b) => b.score - a.score)\n          .slice(0, maxAssignments); // Limiter le nombre d'affectations\n\n        return eligibleEmployees;\n      }),\n      // Effectuer les affectations\n      map(eligibleEmployees => {\n        const assignmentPromises = eligibleEmployees.map(result => \n          this.employeeService.assignEmployeeToJobDescription(result.employee_id, jobId).toPromise()\n        );\n\n        return {\n          eligibleEmployees,\n          assignmentPromises: Promise.all(assignmentPromises)\n        };\n      })\n    );\n  }\n  getMatchingAnalytics(jobId: number): Observable<MatchingAnalytics> {\n    return this.http.get<MatchingAnalytics>(`${this.apiUrl}/${jobId}/analytics`);\n  }\n\n  exportMatchingResults(jobId: number, format: 'pdf' | 'excel' = 'pdf'): Observable<Blob> {\n    return this.http.get(`${this.apiUrl}/${jobId}/export?format=${format}`, {\n      responseType: 'blob'\n    });\n  }\n\n  // Nouvelle méthode pour trouver le meilleur poste pour un employé\n  findBestJobForEmployee(employeeId: number): Observable<MatchingResult[]> {\n    // On va tester l'employé contre tous les postes disponibles\n    return this.http.get<MatchingResult[]>(`${this.apiUrl}/employee/${employeeId}/best-matches`);\n  }\n\n  // Méthode alternative si le backend n'a pas l'endpoint spécifique\n  findBestJobForEmployeeAlternative(employeeId: number, jobDescriptions: any[]): Observable<MatchingResult[]> {\n    // On teste l'employé contre chaque poste et on retourne les résultats triés\n    const matchingPromises = jobDescriptions.map(job => \n      this.getJobEmployeeSkillMatch(job.id).toPromise()\n        .then(results => (results ?? []).filter(result => result.employee_id === employeeId))\n\n        .catch(() => [])\n    );\n\n    return new Observable(observer => {\n      Promise.all(matchingPromises).then(allResults => {\n        const flatResults = allResults.flat().sort((a, b) => b.score - a.score);\n        observer.next(flatResults);\n        observer.complete();\n      }).catch(error => {\n        observer.error(error);\n      });\n    });\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}