{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\nimport { EmployeeCardComponent } from '../../components/employee-card/employee-card.component';\nlet MatchingComponent = class MatchingComponent {\n  constructor(jobDescriptionService, employeeService, matchingService) {\n    this.jobDescriptionService = jobDescriptionService;\n    this.employeeService = employeeService;\n    this.matchingService = matchingService;\n    this.jobDescriptions = [];\n    this.employees = [];\n    this.selectedJobId = null;\n    this.selectedEmployeeId = null;\n    this.matchingResults = [];\n    this.inverseMatchingResults = [];\n    this.loadingJobDescriptions = true;\n    this.loadingEmployees = true;\n    this.loadingMatching = false;\n    this.loadingInverseMatching = false;\n    this.matchingErrorMessage = null;\n    this.inverseMatchingErrorMessage = null;\n  }\n  ngOnInit() {\n    this.loadJobDescriptions();\n    this.loadEmployees();\n  }\n  loadJobDescriptions() {\n    this.loadingJobDescriptions = true;\n    this.jobDescriptionService.getJobDescriptions().subscribe({\n      next: data => {\n        this.jobDescriptions = data;\n        this.loadingJobDescriptions = false;\n      },\n      error: err => {\n        console.error('Error loading job descriptions:', err);\n        this.matchingErrorMessage = 'Erreur lors du chargement des fiches de poste.';\n        this.loadingJobDescriptions = false;\n      }\n    });\n  }\n  loadEmployees() {\n    this.loadingEmployees = true;\n    this.employeeService.getEmployees().subscribe({\n      next: data => {\n        this.employees = data;\n        this.loadingEmployees = false;\n      },\n      error: err => {\n        console.error('Error loading employees:', err);\n        this.inverseMatchingErrorMessage = 'Erreur lors du chargement des employés.';\n        this.loadingEmployees = false;\n      }\n    });\n  }\n  onJobSelect() {\n    this.matchingResults = [];\n    this.matchingErrorMessage = null;\n  }\n  onEmployeeSelect() {\n    this.inverseMatchingResults = [];\n    this.inverseMatchingErrorMessage = null;\n  }\n  performMatching() {\n    if (!this.selectedJobId) {\n      this.matchingErrorMessage = 'Veuillez sélectionner une fiche de poste.';\n      return;\n    }\n    this.loadingMatching = true;\n    this.matchingErrorMessage = null;\n    this.matchingResults = [];\n    this.matchingService.getMatchingResults(this.selectedJobId).subscribe({\n      next: results => {\n        this.matchingResults = results.sort((a, b) => b.score - a.score); // Sort by score descending\n        this.loadingMatching = false;\n      },\n      error: err => {\n        console.error('Error performing matching:', err);\n        this.matchingErrorMessage = 'Erreur lors du calcul du matching. Assurez-vous que le service FastAPI est en cours d\\'exécution.';\n        this.loadingMatching = false;\n      }\n    });\n  }\n  performInverseMatching() {\n    if (!this.selectedEmployeeId) {\n      this.inverseMatchingErrorMessage = 'Veuillez sélectionner un employé.';\n      return;\n    }\n    this.loadingInverseMatching = true;\n    this.inverseMatchingErrorMessage = null;\n    this.inverseMatchingResults = [];\n    // For inverse matching, we iterate through all job descriptions\n    // and call the matching service for each job with the selected employee.\n    // This assumes the backend's /jobemployeeskillmatch/:jobId endpoint\n    // can handle a single employee's skills being matched against a job.\n    // If the backend's /calculate endpoint in FastAPI is used, it would be different.\n    // Current backend endpoint only takes jobId and returns all matching employees for that job.\n    // To do inverse matching, we need to call the matching for each job and filter results.\n    // This might be inefficient for a large number of jobs.\n    // A dedicated inverse matching endpoint on the backend would be ideal.\n    // For demonstration, we'll simulate by calling matching for all jobs and filtering.\n    const promises = [];\n    this.jobDescriptions.forEach(job => {\n      if (job.id) {\n        promises.push(this.matchingService.getMatchingResults(job.id));\n      }\n    });\n    // Combine all observables and process results\n    // This is a simplified approach. A more robust solution would involve a backend endpoint\n    // specifically for inverse matching or a more complex client-side aggregation.\n    Promise.all(promises.map(p => p.toPromise())).then(allResultsArrays => {\n      const allResults = [].concat(...allResultsArrays.filter(r => r !== undefined));\n      this.inverseMatchingResults = allResults.filter(result => result.employee_id === this.selectedEmployeeId).sort((a, b) => b.score - a.score); // Sort by score descending\n      this.loadingInverseMatching = false;\n    }).catch(err => {\n      console.error('Error performing inverse matching:', err);\n      this.inverseMatchingErrorMessage = 'Erreur lors du calcul du matching inverse. Assurez-vous que le service FastAPI est en cours d\\'exécution.';\n      this.loadingInverseMatching = false;\n    });\n  }\n  getEmployeeFromResult(result) {\n    return this.employees.find(emp => emp.id === result.employee_id) || {\n      id: result.employee_id,\n      name: result.name,\n      position: result.position,\n      email: '',\n      hire_date: ''\n    };\n  }\n  getJobDescriptionFromResult(result) {\n    return this.jobDescriptions.find(job => job.id === result.job_description_id);\n  }\n};\nMatchingComponent = __decorate([Component({\n  selector: 'app-matching',\n  standalone: true,\n  imports: [CommonModule, FormsModule, EmployeeCardComponent],\n  templateUrl: './matching.component.html',\n  styleUrls: ['./matching.component.css']\n})], MatchingComponent);\nexport { MatchingComponent };","map":{"version":3,"names":["Component","CommonModule","FormsModule","EmployeeCardComponent","MatchingComponent","constructor","jobDescriptionService","employeeService","matchingService","jobDescriptions","employees","selectedJobId","selectedEmployeeId","matchingResults","inverseMatchingResults","loadingJobDescriptions","loadingEmployees","loadingMatching","loadingInverseMatching","matchingErrorMessage","inverseMatchingErrorMessage","ngOnInit","loadJobDescriptions","loadEmployees","getJobDescriptions","subscribe","next","data","error","err","console","getEmployees","onJobSelect","onEmployeeSelect","performMatching","getMatchingResults","results","sort","a","b","score","performInverseMatching","promises","forEach","job","id","push","Promise","all","map","p","toPromise","then","allResultsArrays","allResults","concat","filter","r","undefined","result","employee_id","catch","getEmployeeFromResult","find","emp","name","position","email","hire_date","getJobDescriptionFromResult","job_description_id","__decorate","selector","standalone","imports","templateUrl","styleUrls"],"sources":["C:\\Users\\h_ref\\Desktop\\frontend\\matchnhire\\src\\app\\app.routes.ts"],"sourcesContent":["import { Component, OnInit } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\nimport { Observable } from 'rxjs';\nimport { JobDescriptionService } from '../../services/job-description.service';\nimport { EmployeeService } from '../../services/employee.service';\nimport { MatchingService } from '../../services/matching.service';\nimport { JobDescription } from '../../models/job-description.model';\nimport { Employee } from '../../models/employee.model';\nimport { MatchingResult } from '../../models/matching.model';\nimport { EmployeeCardComponent } from '../../components/employee-card/employee-card.component';\n\n@Component({\n  selector: 'app-matching',\n  standalone: true,\n  imports: [CommonModule, FormsModule, EmployeeCardComponent],\n  templateUrl: './matching.component.html',\n  styleUrls: ['./matching.component.css']\n})\nexport class MatchingComponent implements OnInit {\n  jobDescriptions: JobDescription[] = [];\n  employees: Employee[] = [];\n  selectedJobId: number | null = null;\n  selectedEmployeeId: number | null = null;\n  matchingResults: MatchingResult[] = [];\n  inverseMatchingResults: MatchingResult[] = [];\n\n  loadingJobDescriptions: boolean = true;\n  loadingEmployees: boolean = true;\n  loadingMatching: boolean = false;\n  loadingInverseMatching: boolean = false;\n\n  matchingErrorMessage: string | null = null;\n  inverseMatchingErrorMessage: string | null = null;\n\n  constructor(\n    private jobDescriptionService: JobDescriptionService,\n    private employeeService: EmployeeService,\n    private matchingService: MatchingService\n  ) { }\n\n  ngOnInit(): void {\n    this.loadJobDescriptions();\n    this.loadEmployees();\n  }\n\n  loadJobDescriptions(): void {\n    this.loadingJobDescriptions = true;\n    this.jobDescriptionService.getJobDescriptions().subscribe({\n      next: (data) => {\n        this.jobDescriptions = data;\n        this.loadingJobDescriptions = false;\n      },\n      error: (err) => {\n        console.error('Error loading job descriptions:', err);\n        this.matchingErrorMessage = 'Erreur lors du chargement des fiches de poste.';\n        this.loadingJobDescriptions = false;\n      }\n    });\n  }\n\n  loadEmployees(): void {\n    this.loadingEmployees = true;\n    this.employeeService.getEmployees().subscribe({\n      next: (data) => {\n        this.employees = data;\n        this.loadingEmployees = false;\n      },\n      error: (err) => {\n        console.error('Error loading employees:', err);\n        this.inverseMatchingErrorMessage = 'Erreur lors du chargement des employés.';\n        this.loadingEmployees = false;\n      }\n    });\n  }\n\n  onJobSelect(): void {\n    this.matchingResults = [];\n    this.matchingErrorMessage = null;\n  }\n\n  onEmployeeSelect(): void {\n    this.inverseMatchingResults = [];\n    this.inverseMatchingErrorMessage = null;\n  }\n\n  performMatching(): void {\n    if (!this.selectedJobId) {\n      this.matchingErrorMessage = 'Veuillez sélectionner une fiche de poste.';\n      return;\n    }\n\n    this.loadingMatching = true;\n    this.matchingErrorMessage = null;\n    this.matchingResults = [];\n\n    this.matchingService.getMatchingResults(this.selectedJobId).subscribe({\n      next: (results) => {\n        this.matchingResults = results.sort((a, b) => b.score - a.score); // Sort by score descending\n        this.loadingMatching = false;\n      },\n      error: (err) => {\n        console.error('Error performing matching:', err);\n        this.matchingErrorMessage = 'Erreur lors du calcul du matching. Assurez-vous que le service FastAPI est en cours d\\'exécution.';\n        this.loadingMatching = false;\n      }\n    });\n  }\n\n  performInverseMatching(): void {\n    if (!this.selectedEmployeeId) {\n      this.inverseMatchingErrorMessage = 'Veuillez sélectionner un employé.';\n      return;\n    }\n\n    this.loadingInverseMatching = true;\n    this.inverseMatchingErrorMessage = null;\n    this.inverseMatchingResults = [];\n\n    // For inverse matching, we iterate through all job descriptions\n    // and call the matching service for each job with the selected employee.\n    // This assumes the backend's /jobemployeeskillmatch/:jobId endpoint\n    // can handle a single employee's skills being matched against a job.\n    // If the backend's /calculate endpoint in FastAPI is used, it would be different.\n\n    // Current backend endpoint only takes jobId and returns all matching employees for that job.\n    // To do inverse matching, we need to call the matching for each job and filter results.\n    // This might be inefficient for a large number of jobs.\n    // A dedicated inverse matching endpoint on the backend would be ideal.\n\n    // For demonstration, we'll simulate by calling matching for all jobs and filtering.\n    const promises: Observable<MatchingResult[]>[] = [];\n    this.jobDescriptions.forEach(job => {\n      if (job.id) {\n        promises.push(this.matchingService.getMatchingResults(job.id));\n      }\n    });\n\n    // Combine all observables and process results\n    // This is a simplified approach. A more robust solution would involve a backend endpoint\n    // specifically for inverse matching or a more complex client-side aggregation.\n    Promise.all(promises.map(p => p.toPromise())).then(allResultsArrays => {\n      const allResults: MatchingResult[] = [].concat(...allResultsArrays.filter(r => r !== undefined) as any);\n      this.inverseMatchingResults = allResults.filter(result => result.employee_id === this.selectedEmployeeId)\n                                              .sort((a, b) => b.score - a.score); // Sort by score descending\n      this.loadingInverseMatching = false;\n    }).catch(err => {\n      console.error('Error performing inverse matching:', err);\n      this.inverseMatchingErrorMessage = 'Erreur lors du calcul du matching inverse. Assurez-vous que le service FastAPI est en cours d\\'exécution.';\n      this.loadingInverseMatching = false;\n    });\n  }\n\n  getEmployeeFromResult(result: MatchingResult): Employee {\n    return this.employees.find(emp => emp.id === result.employee_id) || { \n      id: result.employee_id, \n      name: result.name, \n      position: result.position, \n      email: '', \n      hire_date: '' \n    };\n  }\n\n  getJobDescriptionFromResult(result: MatchingResult): JobDescription | undefined {\n    return this.jobDescriptions.find(job => job.id === result.job_description_id);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}